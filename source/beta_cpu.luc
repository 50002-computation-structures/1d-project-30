module beta_cpu (
    input clk,  // clock
    input slowclk,
    input rst,
    input interrupt,
    input instruction[32],
    input mem_data_input[32],
    output ia[32],
    output mem_data_address[32],
    output mem_data_output[32],
    output wr,
    output debug_pcsel[16],
    output debug_asel[16],
    output debug_bsel[16],
    output debug_wdsel[16]

  ) {
  
  control_unit control_system(.clk(clk));
  alu alu_system;
  regfile regfile_system(.clk(clk));
  
  dff pc[32](#INIT(0),.clk(clk));

  sig asel_out[32];
  sig bsel_out[32];
  sig ra2sel_out[5];
  sig wasel_out[5];
  sig wdsel_out[32];
  sig pcsel_out[32];

  always {
  
    //*****CONTROL unit******// 
    control_system.reset = rst;
    control_system.irq = interrupt;
    control_system.opcode = instruction[31:26];
    
    //*****PC unit******// 
    ia = pc.q; 
    
    regfile_system.write_enable = 0;

    // advance the PC only when slowclk is 1 
    if (slowclk){ 
      regfile_system.write_enable = control_system.werf;
      // PCSEL mux 
      case (control_system.pcsel){
          b000: 
            pcsel_out = pc.q + 4;
          b001:
            pcsel_out = pc.q + 4 + 4 * c{instruction[15], instruction[15:0]};
          b010:
            // protect JT bit 31
            pcsel_out = c{pc.q[31] && regfile_system.read_data_1[31],regfile_system.read_data_1[30:0]};
          b011:
            pcsel_out = h00000008; // illop 
          b100: 
            pcsel_out = h00000004; // irq 
          default:
            pcsel_out = pc.q;
        }
      pc.d = pcsel_out; // setting of pcreg content must happen only when slowclk == 1, don't bring this outside of if(slowclk) clause
    }
    
    //reset mux 
    if (rst){
        pc.d = 32b0; // reset can happen anytime regardless of slowclk
    }
    
    //*****REGFILE*******//
    // RA2SEL mux
    case(control_system.ra2sel){
      b0:
        ra2sel_out = instruction[15:11];
      b1:
        ra2sel_out = instruction[25:21];
      default:
        ra2sel_out = instruction[15:11];
    }

    // WASEL mux 
    case(control_system.wasel){
      b0:
        wasel_out = instruction[25:21];
      b1:
        wasel_out = b11110;
      default:
        wasel_out = instruction[25:21];
    }
    
    regfile_system.read_address_2 = ra2sel_out;
    regfile_system.read_address_1 = instruction[20:16];
    regfile_system.write_address = wasel_out;

    control_system.z = ~|regfile_system.read_data_1;
    mem_data_output = regfile_system.read_data_2;
    
    //******ALU*******//
    // ASEL mux
    alu_system.alufn_signal = control_system.alufn;
    case(control_system.asel){
      b0:
        asel_out = regfile_system.read_data_1;
      b1:
        asel_out = pc.q + 4 + 4 * c{instruction[15], instruction[15:0]};
      default:
        asel_out = regfile_system.read_data_1;
    }

    // BSEL mux
    case(control_system.bsel){
      b0:
        bsel_out = regfile_system.read_data_2;
      b1:
        bsel_out = c{instruction[15], instruction[15:0]};
        
      default:
        bsel_out = regfile_system.read_data_2;
    }

    
    // WDSEL mux
    case(control_system.wdsel){
      b00:
        wdsel_out = pc.q + 4;
      b01: 
        wdsel_out = alu_system.out;
      b10:
        wdsel_out = mem_data_input;
      default:
        wdsel_out = alu_system.out;
    } 
    
    alu_system.a = asel_out;
    alu_system.b = bsel_out; 
    regfile_system.write_data = wdsel_out;
    mem_data_address = alu_system.out;
    wr = control_system.wr;

    // debug values
    debug_pcsel[15:0] = pcsel_out[15:0];
    debug_asel[15:0] = asel_out[15:0];
    debug_bsel[15:0] = bsel_out[15:0];
    debug_wdsel[15:0] = wdsel_out[15:0];

  }
}
