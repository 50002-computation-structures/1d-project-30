module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
  ) {
  
  sig rst;                  // reset signal

  dff next_button(.clk(clk));
  button_conditioner next_button_conditioner;
  edge_detector next_button_edge(#RISE(1), #FALL(0), .clk(clk));

  beta_cpu beta(.clk(clk));
  counter slowclock(#SIZE(28), .clk(clk), .rst(rst));
  edge_detector slowclock_edge(#RISE(1), #FALL(0), .clk(clk));
  
  // ADDC(R31, 7, R1)
  // CMPEQ(R1, R1, R2)
  // ST(R1, 32)
  // LD(R31, 32, R3)
  // BNE(R3, 0, R1)

  const SAMPLE_CODE = {
    32h7823FFFB, 
    32h607F0020, 
    32h643F0020, 
    32h90410800, 
    32hC03F0007
  };
  
  const NUMBER_OF_INSTR = 5;
  memoryunit memory_unit(#DEPTH(16), .clk(clk)); // can fit 16 * 32 bits 
  
  dff writer_counter[$clog2(NUMBER_OF_INSTR)](.clk(clk));
  fsm code_writer(.clk(clk)) = {INSTRUCTIONLOAD, WAIT, RUN};
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
 
  }
  
  always {
    reset_cond.in = ~rst_n;   // input raw inverted reset signal
    rst = reset_cond.out;     // conditioned reset
    
    led = c{3b0, io_button};  // connect buttons to LEDs
    
    usb_tx = usb_rx;          // loop serial port
    
    io_led = 3x{{h00}};
    io_seg = 8b0; // connect segments to the driver
    io_sel = 4b0; // connect digit select to the driver

    // next button
    next_button_conditioner.in = io_button[5];
    next_button_edge = next_button_conditioner.out;

    if (~next_button.q){
      next_button.d = next_button_edge.out;
    }
    
    // driving the beta 
    slowclock_edge.in = slowclock.value[27];
    beta.interrupt = 0;
    beta.slowclk = slowclock_edge.out & io_dip[2][7]; // start
    beta.rst = rst;
  
    // connect memory unit with beta 
    beta.instruction = memory_unit.instruction;
    beta.mem_data_input = memory_unit.data_memory_output;
    memory_unit.ia = beta.ia[31:0]; 
    memory_unit.data_memory_input = beta.mem_data_output; 
    memory_unit.xwr = beta.xwr; 
    memory_unit.waddr = beta.mem_data_address[31:0]; 
    memory_unit.raddr = beta.mem_data_address[31:0]; 
  
    // turn off instruction loading
    memory_unit.instruction_write_enable = b0;
    memory_unit.instruction_towrite = 32b0; 
    
  
    // write some values to RAM first, then run the beta 
    case(code_writer.q){
        // instruction loading
        code_writer.INSTRUCTIONLOAD:
            beta.rst = 1;
            writer_counter.d = writer_counter.q + 1;
            memory_unit.instruction_towrite = SAMPLE_CODE[writer_counter.q];
            memory_unit.instruction_write_enable = b1;
            memory_unit.ia = writer_counter.q<<2; // pad with two zeroes to make it byte addressable
            if (writer_counter.q == NUMBER_OF_INSTR){
                code_writer.d = code_writer.WAIT; // wait one more clock cycle to allow the last instruction to be loaded before start execution
              }
      
        code_writer.WAIT:
            beta.rst = 1;
            code_writer.d = code_writer.RUN;
        
        code_writer.RUN:
            code_writer.d = code_writer.RUN;
    
    }

  // debugger
  case (io_dip[0]){
    h00: // LSB 16 bits of instruction address
      io_led[0] = beta.ia[7:0];
      io_led[1] = beta.ia[15:8];
    h01: // LSB 16 bits of EA
      io_led[0] = beta.mem_data_address[7:0];
      io_led[1] = beta.mem_data_address[15:8];
    h02: // LSB 16 bits of Mem[EA]
      io_led[0] = beta.mem_data_output[7:0];
      io_led[1] = beta.mem_data_output[15:8];
    h03: // LSB 16 bits of current instruction
      io_led[0] = memory_unit.instruction[7:0];
      io_led[1] = memory_unit.instruction[15:8];
    h04: // MSB 16 bits of current instruction
     io_led[0] = memory_unit.instruction[23:16];
     io_led[1] = memory_unit.instruction[31:24];
  }
  }
}