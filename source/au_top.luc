module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
  ) {
  
  // helper signals
  sig rst;                  // reset signal
  sig next;                 // next instruction signal
  sig debug_pcsel[16];
  sig debug_asel[16];
  sig debug_bsel[16];
  sig debug_wdsel[16];

  // Beta CPU
  beta_cpu beta(.clk(clk));

  // manual next button to advance one instruction
  dff next_button(.clk(clk));
  button_conditioner next_button_conditioner(.clk(clk));
  edge_detector next_button_edge(#RISE(1), #FALL(0), .clk(clk));
  
  // interrupt button conditioners, edge detector, and input buffer
  button_conditioner interrupt_button_conditioner[3](.clk(clk));
  edge_detector interrupt_button_edge[3](#RISE(1), #FALL(0), .clk(clk));

  // to run beta at slower clock than FPGA clock
  counter slowclock(#SIZE(28), .clk(clk), .rst(rst));
  edge_detector slowclock_edge(#RISE(1), #FALL(0), .clk(clk));
  edge_detector fastclock_edge(#RISE(1), #FALL(0), .clk(clk)); 
 
  // setup and instantiate memory unit and instruction ROM
  const MEMORY_SIZE = 32;
  instruction_rom instruction_unit(#WORDS(MEMORY_SIZE));
  memory_unit memory_unit(#WORDS(MEMORY_SIZE), .clk(clk)); // can fit 32 * 32 bits 
  
  // MOTHERBOARD 
  // prepare output buffer
  dff beta_output_buffer[32](.clk(clk), .rst(rst)); // 32 bit beta output buffer, hardwired to always read memory_unit value at byte address 0xC
  // prepare input buffer
  dff beta_input_buffer[32](.clk(clk), .rst(rst)); // 32 bit beta input buffer, hardwired to always write memory_unit value at byte address 0x10
  // counter to write instructions from ROM to instruction memory
  dff writer_counter[$clog2(MEMORY_SIZE)](.clk(clk));
  fsm motherboard(.clk(clk)) = {INSTRUCTIONLOAD, RESET, RUN, LOAD_OUTPUT, DISPLAY_OUTPUT, UPDATE_INPUT};
  
  // OTHERS (for debug)
  multi_seven_seg seg(.clk(clk),.rst(rst));
  reset_conditioner reset_cond(.clk(clk));
  
  always {
    reset_cond.in = ~rst_n;   // input raw inverted reset signal
    rst = reset_cond.out;     // conditioned reset
    io_led = 3x{{h00}};       // turn all LED off at first
    usb_tx = usb_rx;          // loop serial port
    io_seg = 8hff; // connect segments to the driver
    io_sel = 4hf; // connect digit select to the driver
    instruction_unit.addr = 0; // always set to 0 initially
    
    led = c{3b0, io_button};  // connect buttons to LEDs
    io_led[2][7] = io_dip[2][7]; // see toggle manual/auto mode
    io_led[2][6] = io_dip[2][6]; // see toggle fastclock 
    io_led[2][5] = slowclock.value[27]; // see slowclock
    io_led[2][4] = slowclock.value[25]; // see fastclock 
    
    // next button
    next_button_conditioner.in = io_button[4];
    next_button_edge.in = next_button_conditioner.out;
    next_button.d = next_button_edge.out;
    
    // driving the beta 
    slowclock_edge.in = slowclock.value[27];
    fastclock_edge.in = slowclock.value[25];
    
    // connect hardware interrupt button 
    interrupt_button_conditioner.in = io_button[2:0];
    interrupt_button_edge.in = interrupt_button_conditioner.out;
    beta.irq = |interrupt_button_edge.out; // IRQ as long as any of of the buttons[2:0] is pressed
    
    // store the button press to input buffer 
    if (|interrupt_button_edge.out){
      if (interrupt_button_edge.out[0]){
            beta_input_buffer.d = 32hB0;
      }
      else if (interrupt_button_edge.out[1]){
            beta_input_buffer.d = 32hB1;
      }
      else if (interrupt_button_edge.out[2]){
            beta_input_buffer.d = 32hB2;
      }
    }

    next = (slowclock_edge.out & io_dip[2][7]) | next_button.q; // proceed either when next button is pressed or io_dip[2][7] is 1

    if (io_dip[2][6]){ // want faster clock
     next = (fastclock_edge.out & io_dip[2][7]) | next_button.q; 
    }

    beta.slowclk = next; 
    beta.rst = rst;
  
    // connect memory unit with beta 
    beta.instruction = memory_unit.id;
    beta.mem_data_input = memory_unit.mrd;
    memory_unit.ia = beta.ia[31:0]; 
    memory_unit.wd = beta.mem_data_output; 
    memory_unit.we = beta.wr; 
    memory_unit.waddr = beta.mem_data_address[31:0]; 
    memory_unit.raddr = beta.mem_data_address[31:0]; 
  
    // turn off instruction loading
    memory_unit.instruction_write_enable = b0;
    memory_unit.instruction_towrite = 32b0; 
    
    // Load ROM instructions to RAM first, then run the Beta 
    case(motherboard.q){
        // instruction loading
        motherboard.INSTRUCTIONLOAD:
            beta.rst = 1;
            writer_counter.d = writer_counter.q + 1;
            instruction_unit.addr = writer_counter.q;
            memory_unit.instruction_towrite = instruction_unit.out;
            memory_unit.instruction_write_enable = b1;
            memory_unit.ia = writer_counter.q<<2; // pad with two zeroes to make it byte addressable because memory_unit expects byte addresing ia
            if ((writer_counter.q + 1) == MEMORY_SIZE){
                motherboard.d = motherboard.RESET; // wait one more clock cycle to allow the last instruction to be loaded before start execution
              }
      
        motherboard.RESET:
            // wait one cycle before reading from RAM after the last write
            // also, reset beta
            beta.rst = 1;
            motherboard.d = motherboard.RUN;
        
        motherboard.RUN:
            // only load output and update input at the the beginning of each "next" instruction cycle 
            // LOAD_OUTPUT will hijack EA for 2 cycles. At this point, the CPU is not receiving a legitimate Mem[EA] if it is doing a LD/LDR 
            // However since "next" is more than 2 cycles, it will be fixed by the third cycle (actual EA coming out from beta is plugged into memory unit
            if (next){
                motherboard.d = motherboard.LOAD_OUTPUT;
            }
            else{
                motherboard.d = motherboard.RUN;
            }
        
        motherboard.LOAD_OUTPUT:
            // load hardcoded byte address 32hC (12) for output 
            memory_unit.raddr = 32hC;
            motherboard.d = motherboard.DISPLAY_OUTPUT;
        
        motherboard.DISPLAY_OUTPUT:
            // display Mem[12] to beta_output_buffer for user to see
            beta_output_buffer.d = memory_unit.mrd;
            motherboard.d = motherboard.UPDATE_INPUT;
        
        motherboard.UPDATE_INPUT:
            // always store hardcoded byte address 32h10 (16) for any incoming input each time "next" happens
            // need 2x original clock cycles for data to be readable at 32h10, plenty of time since "next" is more than 2 cycles
            memory_unit.waddr = 32h10;
            memory_unit.wd = beta_input_buffer.q;
            memory_unit.we = 1;
            motherboard.d = motherboard.RUN;
    }

  // debugger to view Beta state    
  seg.values = {4b0,4b0,4b0,4b0};
  io_seg = ~seg.seg;
  io_sel = ~seg.sel;
  
  debug_pcsel = beta.debug[0];
  debug_asel = beta.debug[1];
  debug_bsel = beta.debug[1];
  debug_wdsel = beta.debug[1];

  case (io_dip[0]){
    h00: // MSB 16 bits of current instruction
      io_led[0] = memory_unit.id[23:16];
      io_led[1] = memory_unit.id[31:24];
      seg.values = {memory_unit.id[31:28], memory_unit.id[27:24], memory_unit.id[23:20], memory_unit.id[19:16]};
    h01: // LSB 16 bits of current instruction
      io_led[0] = memory_unit.id[7:0];
      io_led[1] = memory_unit.id[15:8];
      seg.values = {memory_unit.id[15:12], memory_unit.id[11:8], memory_unit.id[7:4], memory_unit.id[3:0]}; 
    h02: // LSB 16 bits of instruction address
      io_led[0] = beta.ia[7:0];
      io_led[1] = beta.ia[15:8];
      seg.values = {beta.ia[15:12], beta.ia[11:8], beta.ia[7:4], beta.ia[3:0]};
    h0F: // MSB 16 bits of instruction address
      io_led[0] = beta.ia[31:24];
      io_led[1] = beta.ia[23:16];
      seg.values = {beta.ia[31:28], beta.ia[27:24], beta.ia[23:20], beta.ia[19:16]}; 
    h03: // LSB 16 bits of EA (this is also ALU output)
      io_led[0] = beta.mem_data_address[7:0];
      io_led[1] = beta.mem_data_address[15:8];
      seg.values = {beta.mem_data_address[15:12], beta.mem_data_address[11:8], beta.mem_data_address[7:4], beta.mem_data_address[3:0]};
    h04: // MSB 16 bits of EA (this is also ALU output)
      io_led[0] = beta.mem_data_address[23:16];
      io_led[1] = beta.mem_data_address[31:24];
      seg.values = {beta.mem_data_address[31:28], beta.mem_data_address[27:24], beta.mem_data_address[23:20], beta.mem_data_address[19:16]}; 
    h05: // LSB 16 bits of Mem[EA]
      io_led[0] = memory_unit.mrd[7:0];
      io_led[1] = memory_unit.mrd[15:8];
      seg.values = {memory_unit.mrd[15:12], memory_unit.mrd[11:8], memory_unit.mrd[7:4], memory_unit.mrd[3:0]}; 
    h06: // MSB 16 bits of Mem[EA]
      io_led[0] = memory_unit.mrd[23:16];
      io_led[1] = memory_unit.mrd[31:24];
      seg.values = {memory_unit.mrd[31:28], memory_unit.mrd[27:24], memory_unit.mrd[23:20], memory_unit.mrd[19:16]}; 
    h07: // LSB 16 bits of RD2 (mwd[15:0]) 
      io_led[0] = beta.mem_data_output[7:0];
      io_led[1] = beta.mem_data_output[15:8];
      seg.values = {beta.mem_data_output[15:12], beta.mem_data_output[11:8], beta.mem_data_output[7:4], beta.mem_data_output[3:0]};
    h08: // MSB 16 bits of RD2 (mwd[31:16])
      io_led[0] = beta.mem_data_output[23:16];
      io_led[1] = beta.mem_data_output[31:24];
      seg.values = {beta.mem_data_output[31:28], beta.mem_data_output[27:24], beta.mem_data_output[23:20], beta.mem_data_output[19:16]};
    h09: // LSB 16 bits of pcsel_out
      io_led[0] = debug_pcsel[7:0];
      io_led[1] = debug_pcsel[15:8];
      seg.values = {debug_pcsel[15:12], debug_pcsel[11:8], debug_pcsel[7:4], debug_pcsel[3:0]};
    h0A: // LSB 16 bits of asel_out
      io_led[0] = debug_asel[7:0];
      io_led[1] = debug_asel[15:8];
      seg.values = {debug_asel[15:12], debug_asel[11:8], debug_asel[7:4], debug_asel[3:0]};
    h0B: // LSB 16 bits of bsel_out
      io_led[0] = debug_bsel[7:0];
      io_led[1] = debug_bsel[15:8];
      seg.values = {debug_bsel[15:12], debug_bsel[11:8], debug_bsel[7:4], debug_bsel[3:0]};
    h0C: // LSB 16 bits of wdsel_out
      io_led[0] = debug_wdsel[7:0];
      io_led[1] = debug_wdsel[15:8];
      seg.values = {debug_wdsel[15:12], debug_wdsel[11:8], debug_wdsel[7:4], debug_wdsel[3:0]};
    h0D: // LSB 16 bits of beta_output_buffer 
      io_led[1:0] = {beta_output_buffer.q[15:8], beta_output_buffer.q[7:0]};
      seg.values = {beta_output_buffer.q[15:12], beta_output_buffer.q[11:8], beta_output_buffer.q[7:4], beta_output_buffer.q[3:0]}; 
    h0E: // LSB 16 bits of beta_input_buffer
      io_led[1:0] = {beta_input_buffer.q[15:8], beta_input_buffer.q[7:0]};
      seg.values = {beta_input_buffer.q[15:12], beta_input_buffer.q[11:8], beta_input_buffer.q[7:4], beta_input_buffer.q[3:0]}; 
  }
  }
}