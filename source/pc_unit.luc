module pc_unit (
    input clk,  // clock
    input rst,  // reset
    input slowclk, // slowclock to advance pc
    input id[16],
    input pcsel[3],
    input reg_data_1[32],
    output pc_4[32],
    output pc_4_sxtc[32],
    output ia[32]
  ) {

  dff pc[32](#INIT(0),.clk(clk)); // PC Register

  sig pcsel_out[32];
  sig sextc[32];
  sig pc_4_sxtc_sig[32];
  sig pc_4_sig[32];
  
  always {

    // increment pc by 4
    pc_4_sig = c{pc.q[31], pc.q[30:0] + 4};            
    
    // shift-and-add pc by 4
    sextc = 4 * c{id[15], id[15:0]};
    pc_4_sxtc_sig = c{pc.q[31], pc.q[30:0] + 4 + sextc[30:0]};

    // advance the PC only when slowclk is 1 
    if (slowclk){ 
      // PCSEL mux 
      case (pcsel){
          b000: 
            pcsel_out = pc_4_sig;
          b001:
            pcsel_out = pc_4_sxtc_sig;
          b010:
            // JMP mux to protect JT31
            pcsel_out = c{pc.q[31] & reg_data_1[31], reg_data_1[30:0]};
          b011:
            pcsel_out = h80000004; // illop 
          b100: 
            pcsel_out = h80000008; // irq 
          default:
            pcsel_out = pc.q;
        }
      pc.d = c{pcsel_out[31:2], b00}; // setting of pcreg content must happen only when slowclk == 1, don't bring this outside of if(slowclk) clause
    }
    
    // RESET mux 
    if (rst){
        pc.d = h80000000; // reset can happen anytime regardless of slowclk
    }
    
    // output connections
    ia = pc.q;
    pc_4 =  pc_4_sig;
    pc_4_sxtc = pc_4_sxtc_sig;
    
    
  }
}
