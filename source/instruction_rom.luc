module instruction_rom #(
    WORDS = 16 // total instructions in this ROM
)(
    input addr[$clog2(WORDS)], // this ROM is WORD addressable
    output out[32]
  ) {
  
   // Driver code, ADDC is the first instruction, BNE is the last
  const INSTRUCTIONS = {
    32h77FFFFE8, // BR(main) --- reset
    32h6FE50000, // JMP(R5)
    32hC0BF000C, // ADDC(R31, 12, R5) 
    32h649F000C, // ST(R4, 0xC, R31) 
    32hC09F0001, // ADDC(R31, 1, R4)
    32h649F000C, // ST(R4, 0xC, R31) 
    32hC09F0002, // ADDC(R31, 2, R4)
    32h649F000C, // ST(R4, 0xC, R31) 
    32hC09F0003, // ADDC(R31, 3, R4)
    32h649F000C, // ST(R4, 0xC, R31) 
    32hC09F0004, // ADDC(R31, 4, R4)
    32h649F000C, // ST(R4, 0xC, R31) --- countdown 5, 4, 3, 2, 1 to be be displayed at beta_output
    32hC09F0005, // ADDC(R31, 5, R4) --- illop handler, show generic countdown
    32h6FE50000, // JMP(R5) --- execute main
    32hC0BF000C, // ADDC(R31, 12, R5)  
    32h649F000C, // ST(R4, 0xC, R31) --- store to output_buffer: Mem[12] to display the input
    32h609F0010, // LD(R31, 16, R4) --- irq handler, load value from input_buffer: Mem[16]
    32h00000100, // LONG(256) --- trigger illop when R3's value is eventually 0 after several loops to main_sub
    32h7BE3FFFB, // BNE(R3, main_sub, R31) 
    32h607F0020, // LD(R31, 32, R3) 
    32h643F0020, // ST(R1, 32, R31)
    32h90410800, // CMPEQ(R1, R1, R2) 
    32hC4210001, // SUBC(R1, 1, R1) --- main_sub
    32hC03F0003, // ADDC(R31, 7, R1) --- main
    32h77FF0007, // BR(irq)
    32h77FF000C, // BR(illop)
    32h77FF0019 // BR(reset)
  };

  always {
    out = INSTRUCTIONS[addr];
  }
}
